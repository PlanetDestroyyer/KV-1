"""
Curiosity-Driven Learning Engine

Intrinsic motivation for autonomous learning.
Learns because it WANTS to, not just because it needs to!

Features:
- Interest scoring based on novelty and relevance
- Autonomous question generation
- Exploration vs exploitation balance
- Learning for its own sake
"""

from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass
from collections import defaultdict
import random
import math


@dataclass
class CuriosityQuery:
    """A question generated by curiosity."""
    question: str
    interest_score: float  # How interesting is this?
    relevance_score: float  # How relevant to current goal?
    novelty_score: float  # How new/unexplored is this?
    domain: str


class CuriosityEngine:
    """
    Generates intrinsic motivation for learning.

    This is what makes AGI explore autonomously!
    """

    def __init__(self, llm_bridge):
        self.llm = llm_bridge
        self.interest_history: Dict[str, float] = {}  # concept -> interest score
        self.exploration_bonus = 0.3  # How much to value novelty
        self.questions_generated: List[CuriosityQuery] = []
        self.concepts_explored = set()

    async def generate_curious_questions(
        self,
        current_concept: str,
        learned_concepts: List[str],
        domain: str,
        num_questions: int = 3
    ) -> List[CuriosityQuery]:
        """
        Generate questions driven by curiosity.

        These are questions the AGI WANTS to know, not just needs to know!
        """
        print(f"\n[ðŸ¤”] CURIOSITY ENGINE: Generating interesting questions...")

        prompt = f"""You just learned about "{current_concept}" in {domain}.

What you already know: {', '.join(learned_concepts[-10:])}

Generate {num_questions} questions that are:
1. Interesting and thought-provoking
2. Go beyond surface-level facts
3. Connect to what you already know
4. Explore "why" and "how" not just "what"

Format:
QUESTION: [question]
WHY_INTERESTING: [why this is fascinating]
NOVELTY: [0.0-1.0 how unexplored this is]

Example:
QUESTION: Why are there infinitely many prime numbers but they become rarer as numbers get larger?
WHY_INTERESTING: This combines infinity with scarcity - a beautiful paradox!
NOVELTY: 0.8
"""

        response = self.llm.generate(
            system_prompt="You are curious and ask deep, interesting questions.",
            user_input=prompt
        )

        text = response.get("text", "")

        queries = []
        current_q = None
        current_why = ""
        current_novelty = 0.5

        for line in text.split('\n'):
            line = line.strip()

            if line.startswith("QUESTION:"):
                if current_q:
                    # Calculate interest score
                    interest = self._calculate_interest(
                        current_q, current_why, current_novelty, domain
                    )

                    queries.append(CuriosityQuery(
                        question=current_q,
                        interest_score=interest,
                        relevance_score=0.7,  # Related to current learning
                        novelty_score=current_novelty,
                        domain=domain
                    ))

                current_q = line.split("QUESTION:", 1)[1].strip()

            elif line.startswith("WHY_INTERESTING:"):
                current_why = line.split("WHY_INTERESTING:", 1)[1].strip()

            elif line.startswith("NOVELTY:"):
                try:
                    nov_str = line.split("NOVELTY:", 1)[1].strip()
                    current_novelty = float(nov_str.split()[0])
                except:
                    current_novelty = 0.5

        # Save last one
        if current_q:
            interest = self._calculate_interest(
                current_q, current_why, current_novelty, domain
            )

            queries.append(CuriosityQuery(
                question=current_q,
                interest_score=interest,
                relevance_score=0.7,
                novelty_score=current_novelty,
                domain=domain
            ))

        # Display
        for query in queries:
            print(f"[ðŸ’¡] {query.question}")
            print(f"     Interest: {query.interest_score:.2f}, Novelty: {query.novelty_score:.2f}")

        self.questions_generated.extend(queries)
        return queries

    def _calculate_interest(
        self,
        question: str,
        why_interesting: str,
        novelty: float,
        domain: str
    ) -> float:
        """
        Calculate how interesting a question is.

        Combines novelty with intrinsic appeal.
        """
        # Base interest from novelty
        interest = novelty * 0.4

        # Bonus for "why" and "how" questions (deeper)
        if any(word in question.lower() for word in ["why", "how", "what if"]):
            interest += 0.2

        # Bonus for connecting concepts
        if any(word in question.lower() for word in ["connect", "relate", "similar", "different"]):
            interest += 0.15

        # Bonus for paradoxes or contradictions
        if any(word in why_interesting.lower() for word in ["paradox", "contradiction", "surprising", "counter-intuitive"]):
            interest += 0.15

        # Exploration bonus for new domains
        if domain not in self.interest_history:
            interest += self.exploration_bonus

        return min(interest, 1.0)

    async def should_explore_tangent(
        self,
        tangent_concept: str,
        original_goal: str,
        current_depth: int,
        max_depth: int = 3
    ) -> Tuple[bool, str]:
        """
        Decide if a tangent is worth exploring (curiosity-driven).

        Balance exploration (learning cool stuff) vs exploitation (achieve goal).
        """
        # Don't go too deep
        if current_depth >= max_depth:
            return False, f"Already at depth {current_depth}/{max_depth}"

        # Calculate exploration probability
        # Use epsilon-greedy with decay
        exploration_rate = max(0.1, 0.4 - (current_depth * 0.1))

        # Random exploration
        if random.random() < exploration_rate:
            print(f"[ðŸŽ²] CURIOSITY: Exploring tangent '{tangent_concept}' (exploration mode)")
            return True, "Curiosity-driven exploration"

        # Otherwise, check if it's REALLY interesting
        interest = self.interest_history.get(tangent_concept, 0.5)

        if interest > 0.7:
            print(f"[â­] CURIOSITY: Exploring '{tangent_concept}' (high interest: {interest:.2f})")
            return True, f"High interest score: {interest:.2f}"

        return False, f"Low interest ({interest:.2f}) and exploitation mode"

    def update_interest(self, concept: str, interest_delta: float):
        """
        Update interest score for a concept based on experience.

        Positive delta = became more interesting
        Negative delta = less interesting than expected
        """
        current = self.interest_history.get(concept, 0.5)
        new_interest = max(0.0, min(1.0, current + interest_delta))
        self.interest_history[concept] = new_interest

        self.concepts_explored.add(concept)

    async def generate_exploration_goals(
        self,
        domain: str,
        known_concepts: List[str],
        num_goals: int = 3
    ) -> List[str]:
        """
        Generate new learning goals driven purely by curiosity.

        These are goals the AGI wants to pursue, not assigned tasks!
        """
        print(f"\n[ðŸ¤”] CURIOSITY ENGINE: Generating exploration goals...")

        prompt = f"""You've learned these concepts in {domain}: {', '.join(known_concepts[-15:])}

What are {num_goals} fascinating things you'd like to explore next?

Think about:
- Unexplored connections between what you know
- Deeper "why" questions
- Applications you haven't considered
- Edge cases or exceptions

Format:
GOAL: [what you want to learn]
MOTIVATION: [why this excites you]

Example:
GOAL: Explore why some numbers can be expressed as sums of two squares while others cannot
MOTIVATION: I noticed patterns in prime factorization - curious if there's a deeper connection!
"""

        response = self.llm.generate(
            system_prompt="You are intellectually curious and excited to explore new ideas.",
            user_input=prompt
        )

        text = response.get("text", "")

        goals = []
        current_goal = None

        for line in text.split('\n'):
            line = line.strip()

            if line.startswith("GOAL:"):
                current_goal = line.split("GOAL:", 1)[1].strip()

            elif line.startswith("MOTIVATION:") and current_goal:
                motivation = line.split("MOTIVATION:", 1)[1].strip()
                goals.append(current_goal)
                print(f"[ðŸŽ¯] Exploration goal: {current_goal}")
                print(f"     Motivation: {motivation}")
                current_goal = None

        return goals[:num_goals]

    def get_interest_map(self) -> Dict[str, float]:
        """
        Get the current interest map (what's interesting to the AGI).
        """
        return dict(self.interest_history)

    def get_most_interesting_concepts(self, top_k: int = 5) -> List[Tuple[str, float]]:
        """
        Get the concepts that are most interesting.
        """
        sorted_interests = sorted(
            self.interest_history.items(),
            key=lambda x: x[1],
            reverse=True
        )
        return sorted_interests[:top_k]

    def calculate_curiosity_score(
        self,
        concept: str,
        novelty: float,
        relevance: float,
        complexity: float
    ) -> float:
        """
        Calculate overall curiosity score for a concept.

        Curiosity = f(novelty, relevance, complexity)
        - High novelty = interesting
        - Moderate complexity = sweet spot (not too easy, not too hard)
        - Some relevance = connects to existing knowledge
        """
        # Novelty bonus
        novelty_score = novelty * 0.4

        # Relevance bonus (but not too much - we want to explore!)
        relevance_score = relevance * 0.2

        # Complexity sweet spot (inverted U-curve)
        # Optimal around 0.5-0.7 complexity
        if complexity < 0.3:
            complexity_score = 0.1  # Too easy, boring
        elif complexity > 0.9:
            complexity_score = 0.1  # Too hard, frustrating
        else:
            # Peak at 0.6 complexity
            complexity_score = 0.4 * (1 - abs(complexity - 0.6) / 0.6)

        curiosity = novelty_score + relevance_score + complexity_score

        # Exploration bonus for completely new concepts
        if concept not in self.concepts_explored:
            curiosity += self.exploration_bonus

        return min(curiosity, 1.0)

    def get_exploration_stats(self) -> Dict:
        """
        Get statistics about curiosity-driven exploration.
        """
        return {
            "concepts_explored": len(self.concepts_explored),
            "questions_generated": len(self.questions_generated),
            "avg_interest": sum(self.interest_history.values()) / max(len(self.interest_history), 1),
            "high_interest_concepts": len([v for v in self.interest_history.values() if v > 0.7]),
            "exploration_rate": self.exploration_bonus
        }

    def summarize_curiosity(self) -> str:
        """
        Create a summary of curiosity-driven learning.
        """
        lines = [
            "\n" + "="*60,
            "ðŸ¤” CURIOSITY ENGINE SUMMARY",
            "="*60
        ]

        stats = self.get_exploration_stats()
        lines.append(f"\nConcepts explored: {stats['concepts_explored']}")
        lines.append(f"Questions generated: {stats['questions_generated']}")
        lines.append(f"Average interest: {stats['avg_interest']:.2f}")
        lines.append(f"High-interest concepts: {stats['high_interest_concepts']}")

        # Most interesting
        top_interests = self.get_most_interesting_concepts(5)
        if top_interests:
            lines.append("\nMost interesting concepts:")
            for i, (concept, interest) in enumerate(top_interests, 1):
                lines.append(f"  {i}. {concept} (interest: {interest:.2f})")

        # Sample questions
        if self.questions_generated:
            lines.append(f"\nSample curious questions ({len(self.questions_generated)} total):")
            for i, query in enumerate(self.questions_generated[:3], 1):
                lines.append(f"  {i}. {query.question}")
                lines.append(f"     Interest: {query.interest_score:.2f}")

        lines.append("="*60)
        return "\n".join(lines)
